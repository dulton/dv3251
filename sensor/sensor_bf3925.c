/******************** (C) COPYRIGHT 2013 BUILDWIN ************************
* File Name          : sensor_ov9710.c
* Author             : pengtao_zhang
* Version            : V1110a
* Date               : 11/10/2013
* Description        : This file provides all the sensor bf3925 firmware functions.
***************************************************************************/
//===================================================================
//                                                     	            |
//                       INCLUDE FILES                              |
//                                                                  |
//===================================================================
#include "../header/include.h"

#if(SEN_USE == SEN_BF3925)
//===================================================================
//                                                     	            |
//                      GLOBAL VARIABLE                             |
//                                                                  |
//===================================================================

u8 BF3925InitTable_1280_720[][2] =
{
0xff,0x01,
0xf2,0x01,
0xff,0x01,
0x50,0x00,
0x51,0x00,
0xe0,0x01,
0xe1,0x38,
0xe2,0x64,//0x6d,//0x24
0xe3,0xc8,//0x78,//0xc8
0xe4,0xe4,//0xf4,//0x81
0xe5,0x72,
0xe7,0x9b,
0xe9,0x2a,
0xff,0x00,
0x01,0x00,
0x02,0xa0,//0x20
0x03,0x02,
0x04,0x00,
0x10,0x05,
0x11,0x00,
0xff,0x00,
0x05,0xa0,
0x09,0x00,
0x0a,0x48,
0x0b,0x60,
0x0c,0x00,
0x0d,0xb8,
0x0e,0x40,
0xff,0x01,
0x52,0x00,
0x5d,0x02,
0x5a,0x00,
0x5b,0x00,
0x5c,0x00,
0xff,0x01,
0x53,0x60,
0x54,0x40,
0x55,0x00,
0x56,0x40,
0x57,0x00,
0x58,0xb0,
0xff,0x01,
0x50,0x00,
0xff,0x00,
0xb2,0x81,
0xb0,0x15,
0xb1,0x1d,
0xff,0x01,
0x00,0x00,
0x04,0x48,
0x0e,0x0a,
0x0f,0x80,
0x1a,0x28,
0xff,0x00,
0xb2,0x89,
0xff,0x01,
0x00,0x05,
0xff,0x00,
0x52,0x13,
0x53,0x5c,
0x54,0x24,
0x55,0x13,
0x56,0x5c,
0x57,0x24,
0x58,0xd3,
0x59,0x5c,
0x5a,0x24,
0x5b,0x36,//0x46
0x5c,0x33,//0x43
0x5d,0x2d,//0x40
0x5e,0x33,//0x43
/*
0xff,0x00,
0x60,0x30,
0x61,0x2a,
0x62,0x24,
0x63,0x1b,
0x64,0x18,
0x65,0x16,
0x66,0x14,
0x67,0x12,
0x68,0x10,
0x69,0x0e,
0x6a,0x0d,
0x6b,0x0c,
0x6c,0x0a,
0x6d,0x09,
0x6e,0x09,
0x6f,0xf0,
0x70,0x20,
0x71,0x60,
0x72,0x20,
0x73,0x20,
*/
0xff,0x00,
0x60,0x33,
0x61,0x2b,
0x62,0x27,
0x63,0x22,
0x64,0x1b,
0x65,0x17,
0x66,0x14,
0x67,0x11,
0x68,0x0e,
0x69,0x0c,
0x6a,0x0b,
0x6b,0x0a,
0x6c,0x09,
0x6d,0x08,
0x6e,0x07,
0x72,0x20,
0x73,0x20,

0xff,0x00,
0x80,0x0f,
0x81,0x0c,
0x83,0x27,
0x84,0xe6,
0x85,0xa8,
0x86,0xfd,
0x87,0x1a,
0x88,0xa2,
0x89,0xca,
0x8b,0x12,
0x91,0x45,
0xff,0x00,
0xa2,0x04,//0x09
0xa3,0x15,//0x20
0xa4,0x07,
0xa5,0x28,
0xa7,0x1b,
0xa8,0x17,
0xa9,0x12,
0xaa,0x12,
0xab,0x16,
0xac,0x5c,
0xae,0x47,
0xb2,0x89,
0xb3,0x55,
0xb4,0x73,//0x43
0xb5,0x00,
0xb6,0xd9,
0xb8,0xca,
0xbb,0x0d,
0xbc,0x10,
0xbd,0x09,
0xbe,0x24,
0xbf,0x44,
/*
0xff,0x00,
0xc0,0x8a,
0xc1,0x05,
0xc2,0x84,
0xc3,0x86,
0xc4,0x03,
0xc5,0x93,
*/

0xff,0x00,
0xc0,0x83,
0xc1,0x86,
0xc2,0x82,
0xc3,0x8a,
0xc4,0x07,
0xc5,0x9f,

0xc6,0x8a,
0xc7,0x82,
0xc8,0x8b,
0xc9,0x87,
0xca,0x83,
0xcb,0x91,
0xcd,0x30,
0xd0,0x90,
0xd1,0x05,
0xd2,0x82,
0xd3,0x88,
0xd4,0x03,
0xd5,0x93,
0xd6,0x61,
0xff,0x01,
0x00,0x05,
0x01,0x8a,
0x04,0x48,
0x05,0x48,
0x07,0x92,
0x09,0x8c,
0x0b,0x82,
0x0c,0xd4,//0xbe
0x0d,0xb1,//0xa0
0x15,0x42,
0x17,0xb5,
0x18,0x30,
0x1b,0x33,
0x1c,0x66,
0x1d,0x55,
0x1e,0x80,
0x1f,0xd0,//0xc0
0xff,0x01,
0x30,0xe0,
0x31,0x48,
0x32,0xb0, //0xf0
0x34,0xac,//0xc0,//0xda
0x35,0xca,
0x36,0xff,
0x37,0xd0,
0x3b,0x08,
0xff,0x01,
0x3e,0x02,
0xff,0x00, 
0x05,0xa8, 
0x09,0x00, 
0x0a,0x08, 
0x0b,0x50, 
0x0c,0x00, 
0x0d,0xd8, 
0x0e,0x20,  
0xff,0x01, 
0x52,0x20, 
0x5d,0x02,  
0x5a,0x00, 
0x5b,0x00, 
0x5c,0x00,  
0xff,0x01, 
0x53,0x50, 
0x54,0x20, 
0x55,0x00, 
0x56,0x00, 
0x57,0x00, 
0x58,0xd0,  
0xff,0x01, 
0x50,0x00, 

0xff,0x01,
0x0c,0xe5,
0xff,0x01,
0x09,0x84,

0xff,0x01,
0x31,0x48,
0x32,0x30,

0xe8,0x88,

0xff,0x00,
0x00,0x44,
0x05,0xb8,
0x17,0x02,
0x18,0x12,
0x19,0x16,
0x1a,0x14,
0x1b,0x2e,
0x1c,0xf2,
0x1d,0x87,
0x1e,0xb0,
0x1f,0x02,
0x20,0xfa,
0x21,0xb4,
0x22,0xd0,
0x23,0xf8,

0xff,0x00,
0x71,0x00,
0xff,0x00,
0x19,0x18,
0xff,0x01,
0xe1,0x28,
};


/*******************************************************************************
* Function Name  : sensor_Init
* Description    : initialize the sensor
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
u8 sensor_Init(void)
{
     u32 i;
     u8 j;
     u8 u8Buf[2];
     u8 SensorId;
	
	 #if(SYS_CLK == 120000000)
		sensor_ClockInit(24000000);
	 #elif(SYS_CLK == 48000000)
		sensor_ClockInit(24000000);
	 #endif
     u8SensorwriteID = BF3925_I2C_WRITE_ADDR;
     u8SensorreadID  = BF3925_I2C_READ_ADDR;
     u8Addrbytnum = 1;
     u8Databytnum = 1;

	//=======close sensor power ========
	#if (I2C_MAP == I2C_MAP_SW2)			//select software simulate I2C signal
	bI2CBusy_Flag=1;					//set dc check unuse
	bSFBusy_Flag=1;						//set tf card check unuse
	REG32(PMAP_CFG0)  &= ~(1<<14);		//SPI0_MAP0 not mapping to io
	REG32(PMAP_CFG0)  &= ~(1<<7);		// uart not map to io 
	I2C_SCL_SDA_OUT();
	I2C_SCL_LOW();
	I2C_SDA_LOW();
	#endif

	REG32(SYS_CON) = 0x932B;			//SPEC request value
	REG32(LDO_ACON) &= ~(0xf << 4);		//close senosr ldo power

	#if	(USER_CONFIG==CONFIG_AX3251_K6000)		
	Delay_MS(250);		//rc reset need delay, IO reset not do it
	#endif

	#if (I2C_MAP == I2C_MAP_SW2)	//select software simulate I2C signal
	bI2CBusy_Flag=0;
	bSFBusy_Flag=0;
	#endif
	//======end close sensor power=======

	//====sensor ldo open======
	REG32(LDO_ACON) |= (4<<4);   //sensor 3bit 111:3.3v,110:3.2v .... 000:2.6v
	REG32(LDO_ACON) |= (1<<7);   //sensor ldo enable
	Delay_MS(50);
	//===end sensor ldo open====

     i2c_Init(BF3925_I2C_BAUD, BF3925_I2C_WRITE_ADDR,BF3925_I2C_READ_ADDR);
     CLRB(REG32(PCON0), 23);							//csi Clock Enable Bit

	 
     //SENSOR_PIN_CONF();
     //SENSOR_NORMAL();
    // SENSOR_POWERDN();
     SENSOR_NRESET();
     Delay_MS(20);
     SENSOR_RESET();
     Delay_MS(20);
     SENSOR_NRESET();
   //  SENSOR_NORMAL();
     Delay_MS(20);


 	i2c_SendStop();
     SensorId=u8sensor_ReadID();
     if(0x39 != SensorId)
     {
		return 1;
     }

/*
//======test==reg====
   u8 temp1,temp2,temp3,temp4;
     u8Buf[0] = (0xfd & 0xff);
    temp1 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  

    u8Buf[0] = (0xe5 & 0xff);
    temp2 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  
 
    u8Buf[0] = (0xe9 & 0xff);
    temp3 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  

    u8Buf[0] = (0xff & 0xff);
    temp4 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  

//=================
*/



     for(i=0; i<sizeof(BF3925InitTable_1280_720)/2; i++)
     {
          for(j=0; j<(u8Addrbytnum+u8Databytnum); j++) 
         {
             u8Buf[j] = BF3925InitTable_1280_720[i][j];    
         }   
         Sensor_WriteRegister(u8Buf,u8Addrbytnum,u8Databytnum);
         Delay_MS(1);
     } 
	 
	Delay_MS(10);
	i2c_SendStop();

//======test==reg====
   u8 temp1,temp2,temp3,temp4;
     u8Buf[0] = (0xfd & 0xff);
    temp1 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  

    u8Buf[0] = (0xe5 & 0xff);
    temp2 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  
 
    u8Buf[0] = (0xe9 & 0xff);
    temp3 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  

    u8Buf[0] = (0xff & 0xff);
    temp4 = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  

//=================
	sensor_I2C_port_release();
	
	deg_Printf("SensorId=%x\n",SensorId);

	deg_Printf("temp1=%x\n",temp1);
	deg_Printf("temp2=%x\n",temp2);
	deg_Printf("temp3=%x\n",temp3);
	deg_Printf("temp4=%x\n",temp4);

	return 0;
	
}

/*******************************************************************************
* Function Name  : u8sensor_ReadID
* Description    : read sensor chip ID
* Input          : None
* Output         : None
* Return         : sensor chip ID
*******************************************************************************/
u8 u8sensor_ReadID(void)
{
    u8 u8BF3925Id;  
    u8 u8Buf[2]; 
    
    u8Buf[0] = BF3925_CHIP_ID_ADDR & 0xff;
    u8BF3925Id = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  
    deg_Printf("u8BF3925Id=%x\n",u8BF3925Id);
    return  u8BF3925Id;               
}

//=====flag: 0 is rotate 0',  1 is rotate 180'  flip====
void sensor_rotate(u8 flag)
{
	
}
#endif
