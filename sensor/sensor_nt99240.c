/******************** (C) COPYRIGHT 2013 BUILDWIN ************************
* File Name          : sensor_nt99240.c
* Author             : pengtao_zhang
* Version            : V0826a
* Date               : 08/26/2013
* Description        : This file provides all the sensor nt99240 firmware functions.
***************************************************************************/
//===================================================================
//                                                     	            |
//                       INCLUDE FILES                              |
//                                                                  |
//===================================================================
#include "../header/include.h"

#if(SEN_USE == SEN_NT99240)
//===================================================================
//                                                     	            |
//                      GLOBAL VARIABLE                             |
//                                                                  |
//===================================================================

u8 NT99240InitTable_1280_720[][3] =
{

0x32,0xF0, 0x01,
0x30,0x28, 0x07,
0x30,0x29, 0x00,
0x30,0x2a, 0x04,
0x32,0x90, 0x01,
0x32,0x91, 0x94,
0x32,0x96, 0x01,
0x32,0x97, 0x6D,
0x32,0x70, 0x00,
0x32,0x71, 0x0B,
0x32,0x72, 0x16,
0x32,0x73, 0x2B,
0x32,0x74, 0x3F,
0x32,0x75, 0x51,
0x32,0x76, 0x72,
0x32,0x77, 0x8F,
0x32,0x78, 0xA7,
0x32,0x79, 0xBC,
0x32,0x7A, 0xDC,
0x32,0x7B, 0xF0,
0x32,0x7C, 0xFA,
0x32,0x7D, 0xFE,
0x32,0x7E, 0xFF,
0x32,0x00, 0x3E,
0x32,0x10, 0x3A,
0x32,0x11, 0x3A,
0x32,0x12, 0x3A,
0x32,0x13, 0x3A,
0x32,0x14, 0x2A,
0x32,0x15, 0x2A,
0x32,0x16, 0x2A,
0x32,0x17, 0x2A,
0x32,0x18, 0x2A,
0x32,0x19, 0x2A,
0x32,0x1A, 0x2A,
0x32,0x1B, 0x2A,
0x32,0x1C, 0x22,
0x32,0x1D, 0x22,
0x32,0x1E, 0x22,
0x32,0x1F, 0x22,
0x32,0x30, 0x30,
0x32,0x31, 0x00,
0x32,0x32, 0xCF,
0x32,0x33, 0x00,
0x32,0x34, 0x05,
0x33,0x02, 0x00,
0x33,0x03, 0x5F,
0x33,0x04, 0x00,
0x33,0x05, 0x7E,
0x33,0x06, 0x00,
0x33,0x07, 0x22,
0x33,0x08, 0x07,
0x33,0x09, 0xC3,
0x33,0x0A, 0x07,
0x33,0x0B, 0x33,
0x33,0x0C, 0x01,
0x33,0x0D, 0x0A,
0x33,0x0E, 0x00,
0x33,0x0F, 0xD3,
0x33,0x10, 0x07,
0x33,0x11, 0x3B,
0x33,0x12, 0x07,
0x33,0x13, 0xF2,
0x30,0x24, 0x00,
0x30,0x3E, 0x04,
0x30,0x3F, 0x02,
0x30,0x40, 0xFF,
0x30,0x41, 0x02,
0x30,0x51, 0xE0,
0x30,0x52, 0x10,
0x30,0x5f, 0x22,
0x32,0xb0, 0x02,		//0x00  (spot mode)
0x32,0xb1, 0xf0,
0x32,0xb2, 0x01,		// 288 (x_start)
0x32,0xb3, 0x20,
0x32,0xb4, 0x01,		// 344 (y_start)
0x32,0xb5, 0x58,
0x32,0xb6, 0xa9,		//1024x512
0x32,0xBB, 0x0b,
0x32,0xbd, 0x08,
0x32,0xbe, 0x06,
0x32,0xbf, 0x4a,
0x32,0xc0, 0x20,
0x32,0xC3, 0x06,
0x32,0xc5, 0x28,
0x32,0xcd, 0x02,
0x32,0xd3, 0x12,
0x31,0x18, 0xF2,
0x31,0x19, 0xF2,
0x31,0x1A, 0x13,
0x31,0x06, 0x03,
0x31,0x08, 0x00,
0x31,0x12, 0xF1,
0x31,0x13, 0x55,
0x31,0x14, 0x05,
0x30,0x12, 0x03,
0x30,0x13, 0xC0,
0x33,0x26, 0x02,
0x33,0x27, 0x04,
0x33,0x28, 0x04,
0x33,0x29, 0x02,
0x33,0x2A, 0x02,
0x33,0x2B, 0x1D,
0x33,0x2C, 0x1D,
0x33,0x2D, 0x04,
0x33,0x2E, 0x1E,
0x33,0x2F, 0x1F,
0x32,0xf6, 0x0B,
0x33,0x43, 0xE0,
0x33,0x3B, 0x10,
0x33,0x3C, 0x14,
0x33,0x3D, 0x30,
0x33,0x3E, 0x30,
0x33,0x3F, 0x88,
0x33,0x40, 0x84,
0x33,0x41, 0x50,
0x33,0x42, 0x50,
0x33,0x44, 0x20,
0x33,0x45, 0x28,
0x33,0x46, 0x3F,
0x33,0x47, 0x3F,
0x33,0x48, 0xF0,
0x33,0x49, 0x40,
0x33,0x4A, 0x40,
0x33,0x4B, 0x20,
0x33,0x4C, 0x20,
0x33,0x4D, 0x00,
0x32,0xf6, 0x0B,
0x32,0xf9, 0x63,
0x32,0xfA, 0x36,
0x33,0x38, 0x18,
0x33,0x39, 0xC6,
0x33,0x3A, 0x6C,
0x33,0x43, 0xE0,


//[1280x720_20_25_Fps]
0x32,0x00, 0x3e, 
0x32,0x01, 0x0f, 
0x30,0x28, 0x0b, 
0x30,0x29, 0x00, 
0x30,0x2a, 0x04, 
0x30,0x22, 0x24, 
0x30,0x23, 0x24, 
0x30,0x02, 0x00, 
0x30,0x03, 0xa4, 
0x30,0x04, 0x00, 
0x30,0x05, 0xf4, 
0x30,0x06, 0x05, 
0x30,0x07, 0xa3, 
0x30,0x08, 0x03, 
0x30,0x09, 0xc3, 
//0x30,0x0a, 0x06, 
0x30,0x0a, 0x08, 			//set h blanking for remove image line 
0x30,0x0b, 0xf4, 
0x30,0x0c, 0x03, 
0x30,0x0d, 0x28, 
0x30,0x0e, 0x05, 
0x30,0x0f, 0x00, 
0x30,0x10, 0x02, 
0x30,0x11, 0xd0, 
0x30,0x52, 0x10, 
0x32,0xbb, 0x1b, 
//0x32,0xbc, 0x40, 			//AE  light 
0x32,0xbc, 0x38, 			//AE  light 
0x32,0xc1, 0x23, 
0x32,0xc2, 0xf2, 
0x32,0xc8, 0xca, 
0x32,0xc9, 0xa8, 
0x32,0xc4, 0x00, 
0x32,0x01, 0x3f, 
0x30,0x21, 0x16, 
0x30,0x60, 0x01, 

};


/*******************************************************************************
* Function Name  : sensor_Init
* Description    : initialize the sensor
* Input          : None
* Output         : None
* Return         : None
*******************************************************************************/
u8 sensor_Init(void)
{
     u32 i;
     u8 j;
     u8 u8Buf[3];
     u8 SensorId;
     
	 #if(SYS_CLK == 120000000)
		#if(USER_CONFIG == CONFIG_AX3251_K6000)
			#if(DEFAULT_TVOUT_EN == 1) 
			sensor_ClockInit(30000000);
			#else
			sensor_ClockInit(40000000);
			#endif
		#else
		sensor_ClockInit(40000000);
		#endif
	 #elif(SYS_CLK == 48000000)
		sensor_ClockInit(24000000);
	 #endif

     u8SensorwriteID = NT99240_I2C_WRITE_ADDR;
     u8SensorreadID = NT99240_I2C_READ_ADDR;
     u8Addrbytnum = 2;
     u8Databytnum = 1;

	//=======close sensor power ========
	#if (I2C_MAP == I2C_MAP_SW2)			//select software simulate I2C signal
	bI2CBusy_Flag=1;					//set dc check unuse
	bSFBusy_Flag=1;						//set tf card check unuse
	REG32(PMAP_CFG0)  &= ~(1<<14);		//SPI0_MAP0 not mapping to io
	REG32(PMAP_CFG0)  &= ~(1<<7);		// uart not map to io 
	I2C_SCL_SDA_OUT();
	I2C_SCL_LOW();
	I2C_SDA_LOW();
	#endif

	REG32(SYS_CON) = 0x932B;			//SPEC request value
	REG32(LDO_ACON) &= ~(0xf << 4);		//close senosr ldo power

	#if	(USER_CONFIG==CONFIG_AX3251_K6000)		
	Delay_MS(250);		//rc reset need delay, IO reset not do it
	#endif

	#if (I2C_MAP == I2C_MAP_SW2)	//select software simulate I2C signal
	bI2CBusy_Flag=0;
	bSFBusy_Flag=0;
	#endif
	//======end close sensor power=======

	//====sensor ldo open======
	REG32(LDO_ACON) |= (4<<4);   //sensor 3bit 111:3.3v,110:3.2v .... 000:2.6v
	REG32(LDO_ACON) |= (1<<7);   //sensor ldo enable
	Delay_MS(50);
	//===end sensor ldo open====

     i2c_Init(NT99240_I2C_BAUD, NT99240_I2C_WRITE_ADDR,NT99240_I2C_READ_ADDR);
     CLRB(REG32(PCON0), 23);							//csi Clock Enable Bit

     //SENSOR_PIN_CONF();
     //SENSOR_NORMAL();
    // SENSOR_POWERDN();
     SENSOR_NRESET();
     Delay_MS(10);
     SENSOR_RESET();
     Delay_MS(10);
     SENSOR_NRESET();
   //  SENSOR_NORMAL();
     Delay_MS(10);

	i2c_SendStop();
     SensorId = u8sensor_ReadID();
     for(i=0; i<sizeof(NT99240InitTable_1280_720)/3; i++)
     {
          for(j=0; j<(u8Addrbytnum+u8Databytnum); j++) 
         {
             u8Buf[j] = NT99240InitTable_1280_720[i][j];
         }   
         Sensor_WriteRegister(u8Buf,u8Addrbytnum,u8Databytnum);
         Delay_MS(1);
     }

#if (I2C_MAP == I2C_MAP2)		//select PA7(SCL), PA8(SDA)
	REG32(PA_PU0) &= ~(0x0180);
	REG32(PMAP_CFG0)  &= ~BIT(20);//ÓëSPI¸´ÓÃ£¬disable IIC,
	spi_Init(12000000);
	deg_Printf("IIC Disable\n");
#elif (I2C_MAP == I2C_MAP_SW)
	#if ((I2C_SCL_PORT_BIT == 12) && (UART_USE == UART1_MAP1))	//I2C and UART is on the same port
		REG32(PMAP_CFG0)  |= (1<<7);
		REG32(PG_DIR) &= ~(1<<12);
	#endif
#endif
	deg_Printf("SensorId=%x\n",SensorId);
	return 0;
}

/*******************************************************************************
* Function Name  : u8sensor_ReadID
* Description    : read sensor chip ID
* Input          : None
* Output         : None
* Return         : sensor chip ID
*******************************************************************************/
u8 u8sensor_ReadID(void)
{
    u8 u8NT99240Id;  
    u8 u8Buf[3]; 
    
    u8Buf[0] = (NT99240_CHIP_ID_ADDR >> 8) & 0xff;
    u8Buf[1] = NT99240_CHIP_ID_ADDR & 0xff;
    u8NT99240Id = (u8)Sensor_ReadRegister(u8Buf,u8Addrbytnum,u8Databytnum);  

    return  u8NT99240Id;               
}

//=====flag: 0 is rotate 0',  1 is rotate 180'  flip====
void sensor_rotate(u8 flag)
{
	i2c_Init(NT99240_I2C_BAUD, NT99240_I2C_WRITE_ADDR,NT99240_I2C_READ_ADDR);

	if(0 == flag)
	{
		u8 rot_buf[3];
		rot_buf[0] = 0x30;
		rot_buf[1] = 0x22;
		rot_buf[2] = 0x24;
		Sensor_WriteRegister(rot_buf,2,1);
//		deg_Printf("sensor_rotate 0 \n");
	}
	else if(1 == flag)
	{
		u8 rot_buf[3];
		rot_buf[0] = 0x30;
		rot_buf[1] = 0x22;
		rot_buf[2] = 0x27;
		Sensor_WriteRegister(rot_buf,2,1);
//		deg_Printf("sensor_rotate 180 \n");
	}

	sensor_I2C_port_release();
	
}


#endif
